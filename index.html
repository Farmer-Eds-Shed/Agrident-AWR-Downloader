<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Agrident Tasks → CSV</title>
  <style>
    :root { --bd:#ddd; --muted:#666; --bg:#f7f7f7; }
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; max-width: 1100px; }
    h1 { margin: 0 0 6px; font-size: 44px; line-height: 1.05; }
    .muted { color: var(--muted); font-size: 13px; }
    .card { border: 1px solid var(--bd); border-radius: 12px; padding: 12px; margin: 12px 0; background: #fff; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button, select, input { padding: 10px 12px; font-size: 14px; }
    .pill { padding: 2px 10px; border-radius: 999px; background: #eee; font-size: 12px; white-space: nowrap; }
    .ok { background: #e7f7ea; }
    .bad { background: #ffecec; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }

    /* Compact connection card */
    .cardCompact { padding: 10px 12px; }
    .btnRow { display:flex; gap: 8px; width: 100%; }
    .btnRow button { flex: 1; }
    .pillRow { display:flex; gap: 8px; align-items:center; flex-wrap: wrap; width: 100%; }
    .topRow { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; width: 100%; }
    .topRow label { font-size: 13px; color: var(--muted); }
    #connType { min-width: 220px; }

    details.connMore {
      width: 100%;
      margin-top: 8px;
      border-top: 1px solid #eee;
      padding-top: 8px;
    }
    details.connMore > summary {
      cursor: pointer;
      list-style: none;
      user-select: none;
      font-size: 13px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    details.connMore > summary::-webkit-details-marker { display: none; }
    details.connMore > summary:after {
      content: "▾";
      margin-left: auto;
      color: var(--muted);
      font-size: 12px;
    }
    details.connMore[open] > summary:after { content: "▴"; }
    .connMeta { display:flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; }
    .connMeta span { display:inline-block; }

    /* tables */
    table { width:100%; border-collapse: collapse; min-width: 520px; }
    th, td {
      border-bottom: 1px solid #eee;
      padding: 8px 10px;
      text-align: left;
      font-size: 13px;
      vertical-align: top;
    }
    th { background: #fafafa; position: sticky; top: 0; z-index: 1; }
    .scroll {
      max-height: 260px;
      overflow:auto;
      border:1px solid #eee;
      border-radius:8px;
      margin-top:8px;
      -webkit-overflow-scrolling: touch;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    /* ---- Modal ---- */
    .overlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 9999;
    }
    .overlay.show { display: flex; }
    .modal {
      width: min(900px, 100%);
      max-height: min(80vh, 720px);
      background: #fff;
      border: 1px solid var(--bd);
      border-radius: 12px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.18);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .modalHeader {
      padding: 12px 14px;
      border-bottom: 1px solid #eee;
      display:flex; align-items:center; gap:12px;
    }
    .modalTitle { font-weight: 700; }
    .modalBody { padding: 12px 14px; overflow: auto; }
    .grid {
      display: grid;
      grid-template-columns: 260px 1fr;
      gap: 8px 12px;
      align-items: center;
    }
    .grid label {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .grid input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #ddd;
      border-radius: 10px;
      font-size: 14px;
    }
    .modalFooter {
      padding: 12px 14px;
      border-top: 1px solid #eee;
      display:flex; gap:10px; justify-content: flex-end;
      background: #fafafa;
      flex-wrap: wrap;
    }

    .btn {
      border: 1px solid #ddd;
      background: #fff;
      border-radius: 10px;
      cursor: pointer;
    }
    .btnPrimary {
      border-color: #0b6;
      background: #0b6;
      color: #fff;
    }
    .btnDanger {
      border-color: #d33;
      background: #d33;
      color: #fff;
    }
    .btnSmall {
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 10px;
      line-height: 1.1;
    }

    /* --- Mobile improvements --- */
    @media (max-width: 640px) {
      body { margin: 12px; }
      h1 { font-size: 30px; }
      .card { padding: 10px; margin: 10px 0; }
      .cardCompact { padding: 10px; }

      .row { flex-direction: column; align-items: stretch; }
      .row > * { width: 100%; }

      /* keep connection buttons 2-up */
      .btnRow { flex-direction: row; }
      .btnRow button { width: auto; }

      /* keep connection type inline-ish */
      .topRow { flex-direction: column; align-items: stretch; }
      #connType { width: 100%; }

      .pillRow { flex-direction: row; width: 100%; }
      .pill { width: fit-content; }

      button, select, input { width: 100%; }
      #taskSelect { width: 100%; }

      .scroll { max-height: 360px; }
      .grid { grid-template-columns: 1fr; }
      .grid label { white-space: normal; }
      .modalFooter { justify-content: stretch; }
      .modalFooter button { width: 100%; }

      table { min-width: 680px; }
    }
  </style>
</head>
<body>
  <h1>Agrident Tasks → CSV</h1>
  <div class="muted">Agrident/Allflex Tasks Downloader</div>

  <!-- Connection / Status -->
  <div class="card cardCompact" id="connCard">
    <div class="topRow">
      <label for="connType">Connection:</label>
      <select id="connType">
        <option value="ble">Bluetooth (BLE)</option>
        <option value="serial">USB Serial (COM)</option>
      </select>
      <span class="muted" id="connHint" style="margin-left:auto;"></span>
    </div>

    <div class="btnRow" style="margin-top:8px;">
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
    </div>

    <div class="pillRow" style="margin-top:8px;">
      <span id="status" class="pill bad">Disconnected</span>
      <span id="busy" class="pill">idle</span>
    </div>

    <details id="connMore" class="connMore">
      <summary>Connection details</summary>
      <div class="connMeta">
        <span class="muted" id="deviceName"></span>
        <span class="muted" id="syncedAt"></span>
      </div>
    </details>
  </div>

  <!-- Preview -->
  <div class="card">
    <div class="row" style="gap:10px; margin-bottom:10px;">
      <label class="muted" for="taskSelect">Task:</label>
      <select id="taskSelect" disabled>
        <option value="">(connect to load tasks)</option>
      </select>
      <button id="downloadCsvBtn" disabled>Download CSV</button>
    </div>

    <h3 style="margin:0 0 6px;">Preview</h3>
    <div class="muted" id="previewMeta">No task selected.</div>

    <div class="scroll" style="max-height: 320px;">
      <table>
        <thead><tr id="previewHead"></tr></thead>
        <tbody id="previewBody"></tbody>
      </table>
    </div>
  </div>

  <!-- Modal editor -->
  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <div class="modalHeader">
        <div class="modalTitle" id="modalTitle">Edit Row</div>
        <span class="muted" id="modalSubtitle"></span>
        <span style="margin-left:auto;"></span>
        <button class="btn btnSmall" id="modalCloseBtn" title="Close">✕</button>
      </div>

      <div class="modalBody">
        <div class="muted" style="margin-bottom:10px;">
          Tip: Date columns accept <code>08022026</code>, <code>08-02-26</code>, <code>2026-02-08</code> and will export as <code>dd/mm/yyyy</code>.
        </div>
        <div id="modalGrid" class="grid"></div>
      </div>

      <div class="modalFooter">
        <button class="btn" id="modalCancelBtn">Cancel</button>
        <button class="btn btnDanger" id="modalDeleteBtn">Delete Row</button>
        <button class="btn btnPrimary" id="modalSaveBtn">Save</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // BLE UUIDs
  const UUID_BATT_SVC = "battery_service";
  const UUID_BATT_CHR = "battery_level"; // 0x2A19

  // Serial defaults (you said 9600 is default)
  const SERIAL_BAUD = 9600;

  // Defaults
  const APPEND_CR = false;
  const APPEND_LF = false;

  // UI
  const connType = document.getElementById("connType");
  const connHint = document.getElementById("connHint");

  const connectBtn = document.getElementById("connectBtn");
  const disconnectBtn = document.getElementById("disconnectBtn");
  const statusEl = document.getElementById("status");
  const busyEl = document.getElementById("busy");
  const deviceNameEl = document.getElementById("deviceName");
  const syncedAtEl = document.getElementById("syncedAt");
  const connMore = document.getElementById("connMore");

  const taskSelect = document.getElementById("taskSelect");
  const downloadCsvBtn = document.getElementById("downloadCsvBtn");

  const previewMeta = document.getElementById("previewMeta");
  const previewHead = document.getElementById("previewHead");
  const previewBody = document.getElementById("previewBody");

  // Modal elements
  const overlay = document.getElementById("overlay");
  const modalTitle = document.getElementById("modalTitle");
  const modalSubtitle = document.getElementById("modalSubtitle");
  const modalGrid = document.getElementById("modalGrid");
  const modalCloseBtn = document.getElementById("modalCloseBtn");
  const modalCancelBtn = document.getElementById("modalCancelBtn");
  const modalDeleteBtn = document.getElementById("modalDeleteBtn");
  const modalSaveBtn = document.getElementById("modalSaveBtn");

  // Open details by default on desktop, collapsed on mobile
  function setConnDetailsDefault() {
    if (!connMore) return;
    if (window.matchMedia("(min-width: 641px)").matches) connMore.open = true;
    else connMore.open = false;
  }
  setConnDetailsDefault();
  window.addEventListener("resize", () => setConnDetailsDefault());

  function setStatus(text, ok) {
    statusEl.textContent = text;
    statusEl.classList.toggle("ok", !!ok);
    statusEl.classList.toggle("bad", !ok);
  }
  function setBusy(text) { busyEl.textContent = text; }

  const enc = new TextEncoder();
  const dec = new TextDecoder();
  function u8FromDV(dv) { return new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength); }

  // Stream buffer for bracket frames
  let rxText = "";
  const MAX_TEXT = 60000;

  // Command control
  let currentCommand = null;
  let cmdTimer = null;

  // Shared write queue (prevents overlapping writes on both transports)
  const writeQueue = [];
  let writing = false;
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  // App state
  let tasks = [];
  let selectedTask = null;
  let taskHeaders = [];
  let taskRows = [];

  // Modal state
  let editingRealIndex = null;
  let editingHeaders = [];
  let editingInputs = [];
  let lastFocusEl = null;

  // ---- Transport abstraction ----
  const transport = {
    kind: null,          // "ble" | "serial"
    isConnected: false,
    // ble
    ble: { device: null, char: null, onNotify: null },
    // serial
    serial: { port: null, reader: null, keepReading: false },

    async connect(kind) {
      if (this.isConnected) throw new Error("Already connected");
      this.kind = kind;

      if (kind === "ble") return await this._connectBLE();
      if (kind === "serial") return await this._connectSerial();
      throw new Error("Unknown transport");
    },

    async disconnect() {
      if (this.kind === "ble") await this._disconnectBLE();
      if (this.kind === "serial") await this._disconnectSerial();
      this.kind = null;
      this.isConnected = false;
    },

    async write(str) {
      if (!this.isConnected) throw new Error("Not connected");
      if (this.kind === "ble") return await this._writeBLE(str);
      if (this.kind === "serial") return await this._writeSerial(str);
      throw new Error("Unknown transport");
    },

    // ----- BLE -----
    async _connectBLE() {
      if (!("bluetooth" in navigator)) {
        throw new Error("Web Bluetooth not supported in this browser");
      }

      const dev = await navigator.bluetooth.requestDevice({
        filters: [{ services: [UUID_BATT_SVC] }],
        optionalServices: [UUID_BATT_SVC, "generic_access", "device_information"],
      });

      this.ble.device = dev;
      deviceNameEl.textContent = dev.name ? `Selected: ${dev.name}` : `Selected: (BLE device)`;
      dev.addEventListener("gattserverdisconnected", () => cleanup());

      const server = await dev.gatt.connect();
      const svc = await server.getPrimaryService(UUID_BATT_SVC);
      const chr = await svc.getCharacteristic(UUID_BATT_CHR);
      this.ble.char = chr;

      await chr.startNotifications();
      const onNotify = (ev) => {
        const u8 = u8FromDV(ev.target.value);
        const chunk = dec.decode(u8);
        onTextChunk(chunk);
      };
      chr.addEventListener("characteristicvaluechanged", onNotify);
      this.ble.onNotify = onNotify;

      this.isConnected = true;
    },

    async _disconnectBLE() {
      try {
        if (this.ble.char && this.ble.onNotify) {
          this.ble.char.removeEventListener("characteristicvaluechanged", this.ble.onNotify);
        }
      } catch {}
      try { await this.ble.char?.stopNotifications?.().catch(()=>{}); } catch {}
      try { if (this.ble.device?.gatt?.connected) this.ble.device.gatt.disconnect(); } catch {}

      this.ble.device = null;
      this.ble.char = null;
      this.ble.onNotify = null;
    },

    async _writeBLE(str) {
      if (!this.ble.char) throw new Error("BLE characteristic missing");
      await this.ble.char.writeValue(enc.encode(str));
      await sleep(35);
    },

    // ----- Serial -----
    async _connectSerial() {
      if (!("serial" in navigator)) {
        throw new Error("Web Serial not supported (use Chrome/Edge on desktop)");
      }

      const port = await navigator.serial.requestPort();
      await port.open({ baudRate: SERIAL_BAUD });

      this.serial.port = port;
      this.serial.keepReading = true;

      // Best-effort display info
      const info = port.getInfo ? port.getInfo() : null;
      if (info && (info.usbVendorId || info.usbProductId)) {
        deviceNameEl.textContent = `Serial: USB VID ${info.usbVendorId || "?"} PID ${info.usbProductId || "?"} @ ${SERIAL_BAUD}`;
      } else {
        deviceNameEl.textContent = `Serial: Connected @ ${SERIAL_BAUD}`;
      }

      // Start read loop
      this.serial.reader = port.readable.getReader();
      this.isConnected = true;

      (async () => {
        try {
          while (this.serial.keepReading) {
            const { value, done } = await this.serial.reader.read();
            if (done) break;
            if (value) {
              // value is Uint8Array
              const chunk = dec.decode(value);
              onTextChunk(chunk);
            }
          }
        } catch (e) {
          // If cable pulled / port error, cleanup
          cleanup();
        }
      })();
    },

    async _disconnectSerial() {
      this.serial.keepReading = false;

      try { await this.serial.reader?.cancel?.(); } catch {}
      try { this.serial.reader?.releaseLock?.(); } catch {}
      this.serial.reader = null;

      try { await this.serial.port?.close?.(); } catch {}
      this.serial.port = null;
    },

    async _writeSerial(str) {
      const port = this.serial.port;
      if (!port?.writable) throw new Error("Serial port not writable");

      const writer = port.writable.getWriter();
      try {
        await writer.write(enc.encode(str));
      } finally {
        writer.releaseLock();
      }
      await sleep(20);
    }
  };

  function onTextChunk(chunk) {
    rxText += chunk;
    if (rxText.length > MAX_TEXT) rxText = rxText.slice(-MAX_TEXT);
    consumeFrames();
  }

  // ---- Frame extraction ----
  const isBracketFrame = (s) => s.startsWith("[") && s.endsWith("]");
  const isCmdFrame = (s, cmd) => s.startsWith("[" + cmd); // [XSH] and [XSH|0]
  const isOkFrame = (s, okToken) => s.includes(okToken);
  const parsePipeFrame = (frameStr) => frameStr.slice(1, -1).split("|");

  function consumeFrames() {
    while (true) {
      const open = rxText.indexOf("[");
      if (open === -1) {
        if (rxText.length > 1024) rxText = rxText.slice(-256);
        return;
      }
      const close = rxText.indexOf("]", open);
      if (close === -1) return;

      const raw = rxText.slice(open, close + 1);
      rxText = rxText.slice(close + 1);

      const cleaned = raw.replace(/\r/g,"").replace(/\n/g,"");
      onFrame(cleaned);
    }
  }

  // ---- Command plumbing (unchanged) ----
  function beginCommand(name, okToken) {
    if (currentCommand) throw new Error(`Busy running ${currentCommand.name}`);

    let resolve, reject;
    const p = new Promise((res, rej) => { resolve = res; reject = rej; });

    currentCommand = { name, okToken, frames: [], resolve, reject };
    setBusy(name);

    connectBtn.disabled = true;
    disconnectBtn.disabled = false;
    connType.disabled = true;
    taskSelect.disabled = true;
    downloadCsvBtn.disabled = true;

    if (cmdTimer) clearTimeout(cmdTimer);
    cmdTimer = setTimeout(() => {
      const done = currentCommand;
      currentCommand = null;
      setBusy("idle");
      if (done) done.reject(new Error("Timeout"));
      taskSelect.disabled = !(transport.isConnected && tasks.length);
      downloadCsvBtn.disabled = !(transport.isConnected && taskRows.length);
    }, 12000);

    return p;
  }

  function finishCommand(ok, err) {
    if (!currentCommand) return;
    if (cmdTimer) clearTimeout(cmdTimer);
    cmdTimer = null;

    const done = currentCommand;
    currentCommand = null;

    setBusy("idle");
    connectBtn.disabled = true;
    disconnectBtn.disabled = false;
    connType.disabled = true;
    taskSelect.disabled = !(transport.isConnected && tasks.length);
    downloadCsvBtn.disabled = !(transport.isConnected && taskRows.length);

    if (ok) done.resolve(done);
    else done.reject(err || new Error("Command failed"));
  }

  function onFrame(f) {
    if (!currentCommand) return;
    currentCommand.frames.push(f);
    if (isOkFrame(f, currentCommand.okToken)) finishCommand(true);
  }

  async function enqueueWrite(str) {
    writeQueue.push(str);
    pumpWrites();
  }

  async function pumpWrites() {
    if (writing) return;
    writing = true;
    try {
      while (writeQueue.length) {
        const s = writeQueue.shift();
        await transport.write(s);
      }
    } catch (e) {
      if (currentCommand) finishCommand(false, e);
      throw e;
    } finally {
      writing = false;
    }
  }

  async function send(cmd, structured = null) {
    if (!transport.isConnected) throw new Error("Not connected");

    let out = String(cmd).trim();
    if (!out) return null;

    if (!out.startsWith("[")) out = "[" + out;
    if (!out.endsWith("]")) out += "]";

    if (APPEND_CR) out += "\r";
    if (APPEND_LF) out += "\n";

    let p = null;
    if (structured) p = beginCommand(structured.name, structured.okToken);

    await enqueueWrite(out);
    if (p) return await p;
    return null;
  }

  // ---- Field formatting (unchanged) ----
  function pad2(n) { return String(n).padStart(2, "0"); }

  function isValidDMY(dd, mm, yyyy) {
    const d = Number(dd), m = Number(mm), y = Number(yyyy);
    if (!(y >= 1900 && y <= 2100)) return false;
    if (!(m >= 1 && m <= 12)) return false;
    if (!(d >= 1 && d <= 31)) return false;
    const dt = new Date(y, m - 1, d);
    return dt.getFullYear() === y && (dt.getMonth() + 1) === m && dt.getDate() === d;
  }

  function formatDateMaybe(v) {
    const s = String(v ?? "").trim();
    if (!s) return s;

    if (/^\d{2}\/\d{2}\/\d{4}$/.test(s)) return s;

    let m = s.match(/^(\d{2})(\d{2})(\d{4})$/); // ddmmyyyy
    if (m) {
      const dd = m[1], mm = m[2], yyyy = m[3];
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    m = s.match(/^(\d{2})(\d{2})(\d{2})$/); // ddmmyy
    if (m) {
      const dd = m[1], mm = m[2], yy = m[3];
      const yyyy = String(2000 + Number(yy));
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    m = s.match(/^(\d{1,2})-(\d{1,2})-(\d{2}|\d{4})$/); // dd-mm-yy or dd-mm-yyyy
    if (m) {
      const dd = pad2(m[1]), mm = pad2(m[2]);
      let yyyy = m[3];
      if (yyyy.length === 2) yyyy = String(2000 + Number(yyyy));
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})$/); // dd/mm/yy
    if (m) {
      const dd = pad2(m[1]), mm = pad2(m[2]);
      const yyyy = String(2000 + Number(m[3]));
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); // yyyy-mm-dd
    if (m) {
      const yyyy = m[1], mm = pad2(m[2]), dd = pad2(m[3]);
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    if (/^\d{10}$/.test(s) || /^\d{13}$/.test(s)) { // unix
      const ms = s.length === 10 ? Number(s) * 1000 : Number(s);
      const d = new Date(ms);
      if (!isNaN(d.getTime())) {
        return `${pad2(d.getDate())}/${pad2(d.getMonth() + 1)}/${d.getFullYear()}`;
      }
    }

    return s;
  }

  function trimLeadingZerosNumberMaybe(v) {
    const s = String(v ?? "").trim();
    if (!s) return s;
    if (!/^-?\d+(\.\d+)?$/.test(s)) return s;

    const neg = s.startsWith("-");
    const core = neg ? s.slice(1) : s;

    if (core.includes(".")) {
      const [ip, fp] = core.split(".");
      const ip2 = ip.replace(/^0+(?=\d)/, "");
      return (neg ? "-" : "") + (ip2 === "" ? "0" : ip2) + "." + fp;
    } else {
      const core2 = core.replace(/^0+(?=\d)/, "");
      return (neg ? "-" : "") + (core2 === "" ? "0" : core2);
    }
  }

  function formatRow(row, headers) {
    return row.map((v, i) => {
      const raw = String(v ?? "").trim();
      const h = String(headers?.[i] ?? "").toLowerCase();
      if (h.includes("date")) return formatDateMaybe(raw);
      if (h.includes("weight") || h.includes("kg") || h === "wgt") return trimLeadingZerosNumberMaybe(raw);
      return raw;
    });
  }

  function getHeadersForPreview() {
    return taskHeaders.length
      ? taskHeaders
      : (taskRows.length ? Array.from({length: Math.max(...taskRows.map(r => r.length))}, (_,i)=>`Field${i+1}`) : []);
  }

  // ---- Modal editor (unchanged) ----
  function openEditor(realIndex) {
    const row = taskRows[realIndex];
    if (!row) return;

    lastFocusEl = document.activeElement;
    editingRealIndex = realIndex;
    editingHeaders = getHeadersForPreview();
    editingInputs = [];

    modalTitle.textContent = "Edit Row";
    modalSubtitle.textContent = selectedTask
      ? `Task ${selectedTask.idx}: ${selectedTask.name} — Row ${realIndex + 1}`
      : `Row ${realIndex + 1}`;

    modalGrid.innerHTML = "";

    for (let i = 0; i < editingHeaders.length; i++) {
      const h = editingHeaders[i];
      const label = document.createElement("label");
      label.title = h;
      label.textContent = h;

      const inp = document.createElement("input");
      inp.type = "text";
      inp.value = row[i] ?? "";
      inp.dataset.colIndex = String(i);

      inp.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter") { ev.preventDefault(); saveEditor(); }
        if (ev.key === "Escape") { ev.preventDefault(); closeEditor(false); }
      });

      modalGrid.appendChild(label);
      modalGrid.appendChild(inp);
      editingInputs.push(inp);
    }

    overlay.classList.add("show");
    overlay.setAttribute("aria-hidden", "false");
    setTimeout(() => editingInputs[0]?.focus?.(), 0);
  }

  function closeEditor(keepFocus = true) {
    overlay.classList.remove("show");
    overlay.setAttribute("aria-hidden", "true");

    editingRealIndex = null;
    editingHeaders = [];
    editingInputs = [];
    modalGrid.innerHTML = "";

    if (keepFocus && lastFocusEl && typeof lastFocusEl.focus === "function") {
      setTimeout(() => lastFocusEl.focus(), 0);
    }
    lastFocusEl = null;
  }

  function saveEditor() {
    if (editingRealIndex === null) return;
    const idx = editingRealIndex;

    const updated = editingHeaders.map((h, i) => editingInputs[i]?.value ?? "");
    taskRows[idx] = formatRow(updated, editingHeaders);

    closeEditor(true);
    renderPreview();
  }

  function deleteEditorRow() {
    if (editingRealIndex === null) return;
    const idx = editingRealIndex;
    if (!confirm(`Delete row #${idx + 1}?`)) return;

    taskRows.splice(idx, 1);
    closeEditor(true);
    renderPreview();
  }

  overlay.addEventListener("click", (ev) => {
    if (ev.target === overlay) closeEditor(true);
  });

  modalCloseBtn.addEventListener("click", () => closeEditor(true));
  modalCancelBtn.addEventListener("click", () => closeEditor(true));
  modalSaveBtn.addEventListener("click", saveEditor);
  modalDeleteBtn.addEventListener("click", deleteEditorRow);

  document.addEventListener("keydown", (ev) => {
    if (ev.key === "Escape" && overlay.classList.contains("show")) {
      ev.preventDefault();
      closeEditor(true);
    }
  });

  // ---- UI rendering ----
  function renderTasksDropdown() {
    taskSelect.innerHTML = "";
    if (!tasks.length) {
      taskSelect.appendChild(new Option("(no tasks found)", ""));
      taskSelect.disabled = true;
      return;
    }
    taskSelect.appendChild(new Option("(select a task…)", "", true, false));
    for (const t of tasks) {
      taskSelect.appendChild(new Option(`${t.idx}: ${t.name} (${t.count})`, String(t.idx)));
    }
    taskSelect.disabled = false;
  }

  function renderPreview() {
    previewHead.innerHTML = "";
    previewBody.innerHTML = "";

    const headers = getHeadersForPreview();

    for (const h of headers) {
      const th = document.createElement("th");
      th.textContent = h;
      previewHead.appendChild(th);
    }

    const thActions = document.createElement("th");
    thActions.textContent = "Actions";
    previewHead.appendChild(thActions);

    const rowsToShow = taskRows.slice(0, 200);

    for (let visIndex = 0; visIndex < rowsToShow.length; visIndex++) {
      const realIndex = visIndex;
      const r = rowsToShow[visIndex];

      const tr = document.createElement("tr");
      for (let i = 0; i < headers.length; i++) {
        const td = document.createElement("td");
        td.textContent = r[i] ?? "";
        if (headers[i]?.toLowerCase?.().includes("eid")) td.classList.add("mono");
        tr.appendChild(td);
      }

      const tdAct = document.createElement("td");
      tdAct.style.display = "flex";
      tdAct.style.flexDirection = "column";
      tdAct.style.gap = "6px";
      tdAct.style.minWidth = "120px";

      const editBtn = document.createElement("button");
      editBtn.className = "btn btnSmall";
      editBtn.textContent = "Edit";
      editBtn.addEventListener("click", () => openEditor(realIndex));

      const delBtn = document.createElement("button");
      delBtn.className = "btn btnSmall btnDanger";
      delBtn.textContent = "Delete";
      delBtn.addEventListener("click", () => {
        if (!confirm(`Delete row #${realIndex + 1}?`)) return;
        taskRows.splice(realIndex, 1);
        renderPreview();
      });

      tdAct.appendChild(editBtn);
      tdAct.appendChild(delBtn);
      tr.appendChild(tdAct);

      previewBody.appendChild(tr);
    }

    if (!selectedTask) {
      previewMeta.textContent = "No task selected.";
    } else {
      previewMeta.textContent =
        `Task ${selectedTask.idx}: ${selectedTask.name} — ${taskRows.length} record(s), ${headers.length} column(s).`;
    }

    downloadCsvBtn.disabled = !(transport.isConnected && taskRows.length);
  }

  function toCsv(headers, rows) {
    const escCsv = (v) => {
      const s = String(v ?? "");
      if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
      return s;
    };
    const lines = [];
    if (headers && headers.length) lines.push(headers.map(escCsv).join(","));
    for (const r of rows) lines.push(r.map(escCsv).join(","));
    return lines.join("\n");
  }

  function downloadText(filename, text) {
    const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  // ---- Agrident commands ----
  async function runXGTASK() {
    const done = await send("[XGTASK]", { name: "Sync tasks", okToken: "XGTASKOK" });

    const rows = done.frames
      .filter(isBracketFrame)
      .filter(fr => fr !== "[XGTASK]" && fr !== "[XGTASKOK]")
      .filter(fr => fr.includes("|"));

    tasks = rows.map(parsePipeFrame)
      .filter(a => a.length >= 2 && a[0] !== "")
      .map(a => ({
        idx: a[0] ?? "",
        name: a[1] ?? "",
        prefix: a[2] ?? "",
        suffix: a[3] ?? "",
        count: a[4] ?? "",
      }));

    renderTasksDropdown();
    const now = new Date();
    syncedAtEl.textContent = `Synced: ${now.toLocaleString()}`;
  }

  async function runXSH(idx) {
    const done = await send(`[XSH|${idx}]`, { name: "Get headers", okToken: "XSHOK" });

    const headerFrame = done.frames.find(fr =>
      isBracketFrame(fr) &&
      !isCmdFrame(fr, "XSH") &&
      fr !== "[XSHOK]" &&
      fr.includes("|")
    );

    taskHeaders = headerFrame ? parsePipeFrame(headerFrame) : [];
  }

  async function runCSW(idx) {
    const done = await send(`[CSW|${idx}]`, { name: "Get data", okToken: "CSWOK" });

    const dataFrames = done.frames
      .filter(isBracketFrame)
      .filter(fr => !isCmdFrame(fr, "CSW"))
      .filter(fr => fr !== "[CSWOK]");

    const datasetFrames = dataFrames.filter(fr => fr.includes("|"));
    const rawRows = datasetFrames.map(parsePipeFrame);

    const headers = taskHeaders.length
      ? taskHeaders
      : Array.from({ length: Math.max(0, ...rawRows.map(r => r.length)) }, (_, i) => `Field${i + 1}`);

    taskRows = rawRows.map(r => formatRow(r, headers));
  }

  async function loadSelectedTask(idx) {
    selectedTask = tasks.find(t => String(t.idx) === String(idx)) || { idx, name: "(unknown)" };
    taskHeaders = [];
    taskRows = [];
    renderPreview();

    await runXSH(idx);
    await runCSW(idx);
    renderPreview();
  }

  // ---- Connect / Disconnect ----
  async function connect() {
    try {
      setStatus("Connecting…", false);
      setBusy("connecting");

      // clear UI state
      tasks = [];
      selectedTask = null;
      taskHeaders = [];
      taskRows = [];
      rxText = "";
      renderTasksDropdown();
      renderPreview();

      connectBtn.disabled = true;
      disconnectBtn.disabled = false;
      connType.disabled = true;

      // connect transport
      const kind = connType.value;
      await transport.connect(kind);

      setStatus("Connected", true);
      setBusy("idle");

      // load tasks
      await runXGTASK();

    } catch (e) {
      cleanup();
      alert(`Connect failed: ${e?.message || e}`);
    }
  }

  async function cleanup() {
    closeEditor(false);

    try { await transport.disconnect(); } catch {}

    connectBtn.disabled = false;
    disconnectBtn.disabled = true;
    connType.disabled = false;
    taskSelect.disabled = true;
    downloadCsvBtn.disabled = true;

    deviceNameEl.textContent = "";
    syncedAtEl.textContent = "";
    rxText = "";

    tasks = [];
    selectedTask = null;
    taskHeaders = [];
    taskRows = [];
    renderTasksDropdown();
    renderPreview();

    setStatus("Disconnected", false);
    setBusy("idle");
  }

  // ---- Connection type hints ----
  function updateConnHint() {
    if (connType.value === "serial") {
      connHint.textContent = ("serial" in navigator)
        ? "Chrome/Edge desktop (Web Serial)"
        : "Serial not supported in this browser";
    } else {
      connHint.textContent = ("bluetooth" in navigator)
        ? "Chrome/Edge/Android (Web Bluetooth)"
        : "Bluetooth not supported in this browser";
    }
  }
  connType.addEventListener("change", updateConnHint);
  updateConnHint();

  // ---- Events ----
  connectBtn.addEventListener("click", connect);
  disconnectBtn.addEventListener("click", cleanup);

  taskSelect.addEventListener("change", async () => {
    try {
      const idx = taskSelect.value;
      if (!idx) return;
      await loadSelectedTask(idx);
    } catch (e) {
      alert(`Failed to load task: ${e?.message || e}`);
    }
  });

  downloadCsvBtn.addEventListener("click", () => {
    if (!selectedTask) return;

    const safeName = String(selectedTask.name || `task_${selectedTask.idx}`)
      .replace(/[^\w\-]+/g,"_")
      .slice(0, 60);

    const headers = getHeadersForPreview();
    const csv = toCsv(headers, taskRows);
    downloadText(`${safeName}.csv`, csv);
  });

  // initial
  setStatus("Disconnected", false);
  setBusy("idle");
})();
</script>
</body>
</html>
