<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Agrident Tasks → CSV</title>
  <style>
    :root { --bd:#ddd; --muted:#666; --bg:#f7f7f7; }
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; max-width: 1100px; }
    h1 { margin: 0 0 6px; }
    .muted { color: var(--muted); font-size: 13px; }
    .card { border: 1px solid var(--bd); border-radius: 12px; padding: 12px; margin: 12px 0; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button, select { padding: 8px 10px; font-size: 14px; }
    .pill { padding: 2px 10px; border-radius: 999px; background: #eee; font-size: 12px; }
    .ok { background: #e7f7ea; }
    .bad { background: #ffecec; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #eee; padding: 6px 8px; text-align: left; font-size: 13px; }
    th { background: #fafafa; position: sticky; top: 0; }
    .scroll { max-height: 260px; overflow:auto; border:1px solid #eee; border-radius:8px; margin-top:8px; }
  </style>
</head>
<body>
  <h1>Agrident Tasks → CSV</h1>
  <div class="muted">Connect → (auto sync tasks) → select task → (auto fetch headers + data) → download CSV.</div>

  <div class="card">
    <div class="row">
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
      <span id="status" class="pill bad">Disconnected</span>
      <span id="busy" class="pill">idle</span>
      <span class="muted" id="deviceName"></span>
      <span class="muted" style="margin-left:auto;" id="syncedAt"></span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label class="muted">Task:</label>
      <select id="taskSelect" disabled>
        <option value="">(connect to load tasks)</option>
      </select>
      <button id="downloadCsvBtn" disabled>Download CSV</button>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 6px;">Tasks</h3>
    <div class="muted">From <code>[XGTASK] ... [XGTASKOK]</code></div>
    <div class="scroll">
      <table>
        <thead>
          <tr>
            <th>Index</th>
            <th>Name</th>
            <th>Prefix</th>
            <th>Suffix</th>
            <th>Count</th>
          </tr>
        </thead>
        <tbody id="tasksBody"></tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 6px;">Preview</h3>
    <div class="muted" id="previewMeta">No task selected.</div>
    <div class="scroll" style="max-height: 320px;">
      <table>
        <thead><tr id="previewHead"></tr></thead>
        <tbody id="previewBody"></tbody>
      </table>
    </div>
  </div>

<script>
(() => {
  // BLE UUIDs
  const UUID_BATT_SVC = "battery_service";
  const UUID_BATT_CHR = "battery_level"; // 0x2A19

  // Defaults: as per your testing
  const APPEND_CR = false;
  const APPEND_LF = false;

  // UI
  const connectBtn = document.getElementById("connectBtn");
  const disconnectBtn = document.getElementById("disconnectBtn");
  const statusEl = document.getElementById("status");
  const busyEl = document.getElementById("busy");
  const deviceNameEl = document.getElementById("deviceName");
  const syncedAtEl = document.getElementById("syncedAt");

  const taskSelect = document.getElementById("taskSelect");
  const downloadCsvBtn = document.getElementById("downloadCsvBtn");

  const tasksBody = document.getElementById("tasksBody");
  const previewMeta = document.getElementById("previewMeta");
  const previewHead = document.getElementById("previewHead");
  const previewBody = document.getElementById("previewBody");

  function setStatus(text, ok) {
    statusEl.textContent = text;
    statusEl.classList.toggle("ok", !!ok);
    statusEl.classList.toggle("bad", !ok);
  }
  function setBusy(text) { busyEl.textContent = text; }

  // Text/bytes
  const enc = new TextEncoder();
  const dec = new TextDecoder();
  function u8FromDV(dv) { return new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength); }

  // BLE state
  let device = null;
  let battChar = null;

  // Frame buffer (robust bracket extraction)
  let rxText = "";
  const MAX_TEXT = 60000;

  // Command control
  let currentCommand = null; // { name, okToken, frames, resolve, reject }
  let cmdTimer = null;

  // Write queue (prevents "GATT operation already in progress.")
  const writeQueue = [];
  let writing = false;
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  // App state
  let tasks = [];
  let selectedTask = null;
  let taskHeaders = [];
  let taskRows = [];

  // Helpers
  const isBracketFrame = (s) => s.startsWith("[") && s.endsWith("]");
  const isCmdFrame = (s, cmd) => s.startsWith("[" + cmd); // [XSH] and [XSH|0]
  const isOkFrame = (s, okToken) => s.includes(okToken);
  const parsePipeFrame = (frameStr) => frameStr.slice(1, -1).split("|");

  // ---- Field formatting ----
  function pad2(n) { return String(n).padStart(2, "0"); }

  function isValidDMY(dd, mm, yyyy) {
    const d = Number(dd), m = Number(mm), y = Number(yyyy);
    if (!(y >= 1900 && y <= 2100)) return false;
    if (!(m >= 1 && m <= 12)) return false;
    if (!(d >= 1 && d <= 31)) return false;
    // basic month/day sanity
    const dt = new Date(y, m - 1, d);
    return dt.getFullYear() === y && (dt.getMonth() + 1) === m && dt.getDate() === d;
  }

  // Convert common Agrident-ish date shapes to dd/mm/yyyy.
  // Keeps original if it can't parse confidently.
  function formatDateMaybe(v) {
    const s = String(v ?? "").trim();
    if (!s) return s;

    // already dd/mm/yyyy
    if (/^\d{2}\/\d{2}\/\d{4}$/.test(s)) return s;

    // ddmmyyyy (e.g. 08022026)
    let m = s.match(/^(\d{2})(\d{2})(\d{4})$/);
    if (m) {
      const dd = m[1], mm = m[2], yyyy = m[3];
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    // ddmmyy (e.g. 080226 => 08/02/2026)
    m = s.match(/^(\d{2})(\d{2})(\d{2})$/);
    if (m) {
      const dd = m[1], mm = m[2], yy = m[3];
      const yyyy = String(2000 + Number(yy));
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    // dd-mm-yy or dd-mm-yyyy
    m = s.match(/^(\d{1,2})-(\d{1,2})-(\d{2}|\d{4})$/);
    if (m) {
      const dd = pad2(m[1]), mm = pad2(m[2]);
      let yyyy = m[3];
      if (yyyy.length === 2) yyyy = String(2000 + Number(yyyy));
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    // dd/mm/yy
    m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})$/);
    if (m) {
      const dd = pad2(m[1]), mm = pad2(m[2]);
      const yyyy = String(2000 + Number(m[3]));
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    // yyyy-mm-dd (or yyyy/mm/dd)
    m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/);
    if (m) {
      const yyyy = m[1], mm = pad2(m[2]), dd = pad2(m[3]);
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    // unix seconds / ms (if present)
    if (/^\d{10}$/.test(s) || /^\d{13}$/.test(s)) {
      const ms = s.length === 10 ? Number(s) * 1000 : Number(s);
      const d = new Date(ms);
      if (!isNaN(d.getTime())) {
        return `${pad2(d.getDate())}/${pad2(d.getMonth() + 1)}/${d.getFullYear()}`;
      }
    }

    return s;
  }

  // Trim leading zeros in numeric-looking fields (weights, ids, etc.)
  // "00045" -> "45", "0000" -> "0", "00012.30" -> "12.30"
  function trimLeadingZerosNumberMaybe(v) {
    const s = String(v ?? "").trim();
    if (!s) return s;

    if (!/^-?\d+(\.\d+)?$/.test(s)) return s;

    const neg = s.startsWith("-");
    const core = neg ? s.slice(1) : s;

    if (core.includes(".")) {
      const [ip, fp] = core.split(".");
      const ip2 = ip.replace(/^0+(?=\d)/, "");
      return (neg ? "-" : "") + (ip2 === "" ? "0" : ip2) + "." + fp;
    } else {
      const core2 = core.replace(/^0+(?=\d)/, "");
      return (neg ? "-" : "") + (core2 === "" ? "0" : core2);
    }
  }

  // Apply to a whole row.
  // IMPORTANT: Only treat as date if header includes "date" (to avoid EID etc).
  function formatRow(row, headers) {
    return row.map((v, i) => {
      const raw = String(v ?? "").trim();
      const h = String(headers?.[i] ?? "").toLowerCase();

      // date columns: format ddmmyyyy etc.
      if (h.includes("date")) {
        return formatDateMaybe(raw);
      }

      // weight columns: trim leading zeros
      if (h.includes("weight") || h.includes("kg") || h === "wgt") {
        return trimLeadingZerosNumberMaybe(raw);
      }

      return raw;
    });
  }

  function beginCommand(name, okToken) {
    if (currentCommand) throw new Error(`Busy running ${currentCommand.name}`);

    let resolve, reject;
    const p = new Promise((res, rej) => { resolve = res; reject = rej; });

    currentCommand = { name, okToken, frames: [], resolve, reject };
    setBusy(name);

    // UI lock
    connectBtn.disabled = true;
    disconnectBtn.disabled = false;
    taskSelect.disabled = true;
    downloadCsvBtn.disabled = true;

    if (cmdTimer) clearTimeout(cmdTimer);
    cmdTimer = setTimeout(() => {
      const done = currentCommand;
      currentCommand = null;
      setBusy("idle");
      if (done) done.reject(new Error("Timeout"));
      taskSelect.disabled = !(battChar && tasks.length);
      downloadCsvBtn.disabled = !(battChar && taskRows.length);
    }, 12000);

    return p;
  }

  function finishCommand(ok, err) {
    if (!currentCommand) return;
    if (cmdTimer) clearTimeout(cmdTimer);
    cmdTimer = null;

    const done = currentCommand;
    currentCommand = null;

    setBusy("idle");
    connectBtn.disabled = true;
    disconnectBtn.disabled = false;
    taskSelect.disabled = !(battChar && tasks.length);
    downloadCsvBtn.disabled = !(battChar && taskRows.length);

    if (ok) done.resolve(done);
    else done.reject(err || new Error("Command failed"));
  }

  function onFrame(f) {
    if (!currentCommand) return;
    currentCommand.frames.push(f);
    if (isOkFrame(f, currentCommand.okToken)) finishCommand(true);
  }

  function consumeFrames() {
    while (true) {
      const open = rxText.indexOf("[");
      if (open === -1) {
        if (rxText.length > 1024) rxText = rxText.slice(-256);
        return;
      }
      const close = rxText.indexOf("]", open);
      if (close === -1) return;

      const raw = rxText.slice(open, close + 1);
      rxText = rxText.slice(close + 1);

      const cleaned = raw.replace(/\r/g,"").replace(/\n/g,"");
      onFrame(cleaned);
    }
  }

  async function enqueueWrite(str) {
    if (!battChar) throw new Error("Not connected");
    writeQueue.push(str);
    pumpWrites();
  }

  async function pumpWrites() {
    if (writing) return;
    writing = true;
    try {
      while (writeQueue.length) {
        const s = writeQueue.shift();
        await battChar.writeValue(enc.encode(s));
        await sleep(35);
      }
    } catch (e) {
      if (currentCommand) finishCommand(false, e);
    } finally {
      writing = false;
    }
  }

  async function send(cmd, structured = null) {
    if (!battChar) throw new Error("Not connected");

    let out = String(cmd).trim();
    if (!out) return null;

    if (!out.startsWith("[")) out = "[" + out;
    if (!out.endsWith("]")) out += "]";

    if (APPEND_CR) out += "\r";
    if (APPEND_LF) out += "\n";

    let p = null;
    if (structured) p = beginCommand(structured.name, structured.okToken);

    await enqueueWrite(out);
    if (p) return await p;
    return null;
  }

  // Render
  function esc(s) {
    return String(s ?? "").replace(/[&<>"']/g, (m) => ({
      "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;"
    }[m]));
  }

  function renderTasks() {
    tasksBody.innerHTML = "";
    for (const t of tasks) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${esc(t.idx)}</td>
        <td>${esc(t.name)}</td>
        <td>${esc(t.prefix)}</td>
        <td>${esc(t.suffix)}</td>
        <td>${esc(t.count)}</td>
      `;
      tasksBody.appendChild(tr);
    }

    taskSelect.innerHTML = "";
    if (!tasks.length) {
      taskSelect.appendChild(new Option("(no tasks found)", ""));
      taskSelect.disabled = true;
      return;
    }
    taskSelect.appendChild(new Option("(select a task…)", "", true, false));
    for (const t of tasks) {
      taskSelect.appendChild(new Option(`${t.idx}: ${t.name} (${t.count})`, String(t.idx)));
    }
    taskSelect.disabled = false;
  }

  function renderPreview() {
    previewHead.innerHTML = "";
    previewBody.innerHTML = "";

    const headers = taskHeaders.length
      ? taskHeaders
      : (taskRows.length ? Array.from({length: Math.max(...taskRows.map(r => r.length))}, (_,i)=>`Field${i+1}`) : []);

    for (const h of headers) {
      const th = document.createElement("th");
      th.textContent = h;
      previewHead.appendChild(th);
    }

    const rowsToShow = taskRows.slice(0, 200);
    for (const r of rowsToShow) {
      const tr = document.createElement("tr");
      for (let i = 0; i < headers.length; i++) {
        const td = document.createElement("td");
        td.textContent = r[i] ?? "";
        tr.appendChild(td);
      }
      previewBody.appendChild(tr);
    }

    if (!selectedTask) {
      previewMeta.textContent = "No task selected.";
    } else {
      previewMeta.textContent =
        `Task ${selectedTask.idx}: ${selectedTask.name} — ${taskRows.length} record(s), ${headers.length} column(s).`;
    }

    downloadCsvBtn.disabled = !(battChar && taskRows.length);
  }

  // CSV
  function toCsv(headers, rows) {
    const escCsv = (v) => {
      const s = String(v ?? "");
      if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
      return s;
    };
    const lines = [];
    if (headers && headers.length) lines.push(headers.map(escCsv).join(","));
    for (const r of rows) lines.push(r.map(escCsv).join(","));
    return lines.join("\n");
  }

  function downloadText(filename, text) {
    const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  // Commands
  async function runXGTASK() {
    const done = await send("[XGTASK]", { name: "Sync tasks", okToken: "XGTASKOK" });

    const rows = done.frames
      .filter(s => s.startsWith("[") && s.endsWith("]"))
      .filter(fr => fr !== "[XGTASK]" && fr !== "[XGTASKOK]")
      .filter(fr => fr.includes("|"));

    tasks = rows.map(parsePipeFrame)
      .filter(a => a.length >= 2 && a[0] !== "")
      .map(a => ({
        idx: a[0] ?? "",
        name: a[1] ?? "",
        prefix: a[2] ?? "",
        suffix: a[3] ?? "",
        count: a[4] ?? "",
      }));

    renderTasks();
    const now = new Date();
    syncedAtEl.textContent = `Synced: ${now.toLocaleString()}`;
  }

  async function runXSH(idx) {
    const done = await send(`[XSH|${idx}]`, { name: "Get headers", okToken: "XSHOK" });

    const headerFrame = done.frames.find(fr =>
      fr.startsWith("[") && fr.endsWith("]") &&
      !fr.startsWith("[XSH") &&
      fr !== "[XSHOK]" &&
      fr.includes("|")
    );

    taskHeaders = headerFrame ? parsePipeFrame(headerFrame) : [];
  }

  async function runCSW(idx) {
    const done = await send(`[CSW|${idx}]`, { name: "Get data", okToken: "CSWOK" });

    const dataFrames = done.frames
      .filter(fr => fr.startsWith("[") && fr.endsWith("]"))
      .filter(fr => !fr.startsWith("[CSW"))
      .filter(fr => fr !== "[CSWOK]");

    const datasetFrames = dataFrames.filter(fr => fr.includes("|"));
    const rawRows = datasetFrames.map(parsePipeFrame);

    const headers = taskHeaders.length
      ? taskHeaders
      : Array.from({ length: Math.max(0, ...rawRows.map(r => r.length)) }, (_, i) => `Field${i + 1}`);

    taskRows = rawRows.map(r => formatRow(r, headers));
  }

  async function loadSelectedTask(idx) {
    selectedTask = tasks.find(t => String(t.idx) === String(idx)) || { idx, name: "(unknown)" };
    taskHeaders = [];
    taskRows = [];
    renderPreview();

    await runXSH(idx);
    await runCSW(idx);
    renderPreview();
  }

  // Connect/disconnect
  async function connect() {
    if (!("bluetooth" in navigator)) {
      alert("Web Bluetooth not supported in this browser.");
      return;
    }
    try {
      setStatus("Connecting…", false);
      setBusy("connecting");

      device = await navigator.bluetooth.requestDevice({
        filters: [{ services: [UUID_BATT_SVC] }],
        optionalServices: [UUID_BATT_SVC, "generic_access", "device_information"],
      });

      deviceNameEl.textContent = device.name ? `Selected: ${device.name}` : "";
      device.addEventListener("gattserverdisconnected", () => cleanup());

      const server = await device.gatt.connect();
      const svc = await server.getPrimaryService(UUID_BATT_SVC);
      battChar = await svc.getCharacteristic(UUID_BATT_CHR);

      await battChar.startNotifications();
      battChar.addEventListener("characteristicvaluechanged", (ev) => {
        const u8 = u8FromDV(ev.target.value);
        const chunk = dec.decode(u8);
        rxText += chunk;
        if (rxText.length > MAX_TEXT) rxText = rxText.slice(-MAX_TEXT);
        consumeFrames();
      });

      setStatus("Connected", true);
      setBusy("idle");

      connectBtn.disabled = true;
      disconnectBtn.disabled = false;

      tasks = [];
      selectedTask = null;
      taskHeaders = [];
      taskRows = [];
      renderTasks();
      renderPreview();

      await runXGTASK();

    } catch (e) {
      cleanup();
      alert(`Connect failed: ${e?.message || e}`);
    }
  }

  function cleanup() {
    try { battChar?.stopNotifications?.().catch(()=>{}); } catch {}
    battChar = null;

    try { if (device?.gatt?.connected) device.gatt.disconnect(); } catch {}
    device = null;

    connectBtn.disabled = false;
    disconnectBtn.disabled = true;
    taskSelect.disabled = true;
    downloadCsvBtn.disabled = true;

    deviceNameEl.textContent = "";
    syncedAtEl.textContent = "";

    tasks = [];
    selectedTask = null;
    taskHeaders = [];
    taskRows = [];
    renderTasks();
    renderPreview();

    setStatus("Disconnected", false);
    setBusy("idle");
  }

  // Events
  connectBtn.addEventListener("click", connect);
  disconnectBtn.addEventListener("click", cleanup);

  taskSelect.addEventListener("change", async () => {
    try {
      const idx = taskSelect.value;
      if (!idx) return;
      await loadSelectedTask(idx);
    } catch (e) {
      alert(`Failed to load task: ${e?.message || e}`);
    }
  });

  downloadCsvBtn.addEventListener("click", () => {
    if (!selectedTask) return;

    const safeName = String(selectedTask.name || `task_${selectedTask.idx}`)
      .replace(/[^\w\-]+/g,"_")
      .slice(0, 60);

    const headers = taskHeaders.length
      ? taskHeaders
      : (taskRows.length ? Array.from({length: Math.max(...taskRows.map(r => r.length))}, (_,i)=>`Field${i+1}`) : []);

    const csv = toCsv(headers, taskRows);
    downloadText(`${safeName}.csv`, csv);
  });

  // init
  setStatus("Disconnected", false);
  setBusy("idle");
})();
</script>
</body>
</html>
