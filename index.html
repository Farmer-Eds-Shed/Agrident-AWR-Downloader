<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Agrident Tasks → CSV</title>
  <style>
    :root { --bd:#ddd; --muted:#666; --bg:#f7f7f7; }
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; max-width: 1100px; }
    h1 { margin: 0 0 6px; font-size: 44px; line-height: 1.05; }
    .muted { color: var(--muted); font-size: 13px; }
    .card { border: 1px solid var(--bd); border-radius: 12px; padding: 12px; margin: 12px 0; background: #fff; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button, select, input { padding: 10px 12px; font-size: 14px; }
    .pill { padding: 2px 10px; border-radius: 999px; background: #eee; font-size: 12px; white-space: nowrap; }
    .ok { background: #e7f7ea; }
    .bad { background: #ffecec; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }

    /* tables */
    table { width:100%; border-collapse: collapse; min-width: 520px; }
    th, td {
      border-bottom: 1px solid #eee;
      padding: 8px 10px;
      text-align: left;
      font-size: 13px;
      vertical-align: top;
    }
    th { background: #fafafa; position: sticky; top: 0; z-index: 1; }
    .scroll {
      max-height: 260px;
      overflow:auto;
      border:1px solid #eee;
      border-radius:8px;
      margin-top:8px;
      -webkit-overflow-scrolling: touch;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    /* ---- Modal ---- */
    .overlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 9999;
    }
    .overlay.show { display: flex; }
    .modal {
      width: min(900px, 100%);
      max-height: min(80vh, 720px);
      background: #fff;
      border: 1px solid var(--bd);
      border-radius: 12px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.18);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .modalHeader {
      padding: 12px 14px;
      border-bottom: 1px solid #eee;
      display:flex; align-items:center; gap:12px;
    }
    .modalTitle { font-weight: 700; }
    .modalBody { padding: 12px 14px; overflow: auto; }
    .grid {
      display: grid;
      grid-template-columns: 260px 1fr;
      gap: 8px 12px;
      align-items: center;
    }
    .grid label {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .grid input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #ddd;
      border-radius: 10px;
      font-size: 14px;
    }
    .modalFooter {
      padding: 12px 14px;
      border-top: 1px solid #eee;
      display:flex; gap:10px; justify-content: flex-end;
      background: #fafafa;
      flex-wrap: wrap;
    }

    .btn {
      border: 1px solid #ddd;
      background: #fff;
      border-radius: 10px;
      cursor: pointer;
    }
    .btnPrimary {
      border-color: #0b6;
      background: #0b6;
      color: #fff;
    }
    .btnDanger {
      border-color: #d33;
      background: #d33;
      color: #fff;
    }
    .btnSmall {
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 10px;
      line-height: 1.1;
    }

    /* --- Mobile improvements --- */
    @media (max-width: 640px) {
      body { margin: 12px; }
      h1 { font-size: 32px; }

      .card { padding: 12px; }

      /* stack rows */
      .row { flex-direction: column; align-items: stretch; }
      .row > * { width: 100%; }

      /* pills / small info: let them wrap and not force weird spacing */
      .pill { display: inline-block; width: fit-content; }
      #deviceName, #syncedAt { display: block; width: 100%; }

      /* make controls full width */
      button, select, input { width: 100%; }
      #taskSelect { width: 100%; }

      /* slightly taller preview on phones */
      .scroll { max-height: 360px; }

      /* modal grid becomes single column */
      .grid { grid-template-columns: 1fr; }
      .grid label { white-space: normal; }
      .modalFooter { justify-content: stretch; }
      .modalFooter button { width: 100%; }

      /* tables need easy horizontal scroll and less min-width */
      table { min-width: 680px; } /* allow sideways scroll but keep columns readable */
    }
  </style>
</head>
<body>
  <h1>Agrident Tasks → CSV</h1>
  <div class="muted">Connect → (auto sync tasks) → select task → (auto fetch headers + data) → optionally edit/delete rows → download CSV.</div>

  <div class="card">
    <div class="row">
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
      <span id="status" class="pill bad">Disconnected</span>
      <span id="busy" class="pill">idle</span>
      <span class="muted" id="deviceName"></span>
      <span class="muted" style="margin-left:auto;" id="syncedAt"></span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label class="muted">Task:</label>
      <select id="taskSelect" disabled>
        <option value="">(connect to load tasks)</option>
      </select>
      <button id="downloadCsvBtn" disabled>Download CSV</button>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 6px;">Tasks</h3>
    <div class="muted">From <code>[XGTASK] ... [XGTASKOK]</code></div>
    <div class="scroll">
      <table>
        <thead>
          <tr>
            <th>Index</th>
            <th>Name</th>
            <th>Prefix</th>
            <th>Suffix</th>
            <th>Count</th>
          </tr>
        </thead>
        <tbody id="tasksBody"></tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 6px;">Preview</h3>
    <div class="muted" id="previewMeta">No task selected.</div>
    <div class="scroll" style="max-height: 320px;">
      <table>
        <thead><tr id="previewHead"></tr></thead>
        <tbody id="previewBody"></tbody>
      </table>
    </div>
  </div>

  <!-- Modal editor -->
  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <div class="modalHeader">
        <div class="modalTitle" id="modalTitle">Edit Row</div>
        <span class="muted" id="modalSubtitle"></span>
        <span style="margin-left:auto;"></span>
        <button class="btn btnSmall" id="modalCloseBtn" title="Close">✕</button>
      </div>

      <div class="modalBody">
        <div class="muted" style="margin-bottom:10px;">
          Tip: Date columns accept <code>08022026</code>, <code>08-02-26</code>, <code>2026-02-08</code> and will export as <code>dd/mm/yyyy</code>.
        </div>
        <div id="modalGrid" class="grid"></div>
      </div>

      <div class="modalFooter">
        <button class="btn" id="modalCancelBtn">Cancel</button>
        <button class="btn btnDanger" id="modalDeleteBtn">Delete Row</button>
        <button class="btn btnPrimary" id="modalSaveBtn">Save</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // BLE UUIDs
  const UUID_BATT_SVC = "battery_service";
  const UUID_BATT_CHR = "battery_level"; // 0x2A19

  // Defaults: as per your testing
  const APPEND_CR = false;
  const APPEND_LF = false;

  // UI
  const connectBtn = document.getElementById("connectBtn");
  const disconnectBtn = document.getElementById("disconnectBtn");
  const statusEl = document.getElementById("status");
  const busyEl = document.getElementById("busy");
  const deviceNameEl = document.getElementById("deviceName");
  const syncedAtEl = document.getElementById("syncedAt");

  const taskSelect = document.getElementById("taskSelect");
  const downloadCsvBtn = document.getElementById("downloadCsvBtn");

  const tasksBody = document.getElementById("tasksBody");
  const previewMeta = document.getElementById("previewMeta");
  const previewHead = document.getElementById("previewHead");
  const previewBody = document.getElementById("previewBody");

  // Modal elements
  const overlay = document.getElementById("overlay");
  const modalTitle = document.getElementById("modalTitle");
  const modalSubtitle = document.getElementById("modalSubtitle");
  const modalGrid = document.getElementById("modalGrid");
  const modalCloseBtn = document.getElementById("modalCloseBtn");
  const modalCancelBtn = document.getElementById("modalCancelBtn");
  const modalDeleteBtn = document.getElementById("modalDeleteBtn");
  const modalSaveBtn = document.getElementById("modalSaveBtn");

  function setStatus(text, ok) {
    statusEl.textContent = text;
    statusEl.classList.toggle("ok", !!ok);
    statusEl.classList.toggle("bad", !ok);
  }
  function setBusy(text) { busyEl.textContent = text; }

  // Text/bytes
  const enc = new TextEncoder();
  const dec = new TextDecoder();
  function u8FromDV(dv) { return new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength); }

  // BLE state
  let device = null;
  let battChar = null;

  // Frame buffer (robust bracket extraction)
  let rxText = "";
  const MAX_TEXT = 60000;

  // Command control
  let currentCommand = null; // { name, okToken, frames, resolve, reject }
  let cmdTimer = null;

  // Write queue (prevents "GATT operation already in progress.")
  const writeQueue = [];
  let writing = false;
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  // App state
  let tasks = [];
  let selectedTask = null;
  let taskHeaders = [];
  let taskRows = [];

  // Modal editing state
  let editingRealIndex = null; // index into taskRows
  let editingHeaders = [];
  let editingInputs = []; // input elements
  let lastFocusEl = null;

  // Helpers
  const isBracketFrame = (s) => s.startsWith("[") && s.endsWith("]");
  const isCmdFrame = (s, cmd) => s.startsWith("[" + cmd); // [XSH] and [XSH|0]
  const isOkFrame = (s, okToken) => s.includes(okToken);
  const parsePipeFrame = (frameStr) => frameStr.slice(1, -1).split("|");

  // ---- Field formatting ----
  function pad2(n) { return String(n).padStart(2, "0"); }

  function isValidDMY(dd, mm, yyyy) {
    const d = Number(dd), m = Number(mm), y = Number(yyyy);
    if (!(y >= 1900 && y <= 2100)) return false;
    if (!(m >= 1 && m <= 12)) return false;
    if (!(d >= 1 && d <= 31)) return false;
    const dt = new Date(y, m - 1, d);
    return dt.getFullYear() === y && (dt.getMonth() + 1) === m && dt.getDate() === d;
  }

  function formatDateMaybe(v) {
    const s = String(v ?? "").trim();
    if (!s) return s;

    if (/^\d{2}\/\d{2}\/\d{4}$/.test(s)) return s;

    let m = s.match(/^(\d{2})(\d{2})(\d{4})$/); // ddmmyyyy
    if (m) {
      const dd = m[1], mm = m[2], yyyy = m[3];
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    m = s.match(/^(\d{2})(\d{2})(\d{2})$/); // ddmmyy
    if (m) {
      const dd = m[1], mm = m[2], yy = m[3];
      const yyyy = String(2000 + Number(yy));
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    m = s.match(/^(\d{1,2})-(\d{1,2})-(\d{2}|\d{4})$/); // dd-mm-yy or dd-mm-yyyy
    if (m) {
      const dd = pad2(m[1]), mm = pad2(m[2]);
      let yyyy = m[3];
      if (yyyy.length === 2) yyyy = String(2000 + Number(yyyy));
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})$/); // dd/mm/yy
    if (m) {
      const dd = pad2(m[1]), mm = pad2(m[2]);
      const yyyy = String(2000 + Number(m[3]));
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); // yyyy-mm-dd
    if (m) {
      const yyyy = m[1], mm = pad2(m[2]), dd = pad2(m[3]);
      if (isValidDMY(dd, mm, yyyy)) return `${dd}/${mm}/${yyyy}`;
      return s;
    }

    if (/^\d{10}$/.test(s) || /^\d{13}$/.test(s)) { // unix
      const ms = s.length === 10 ? Number(s) * 1000 : Number(s);
      const d = new Date(ms);
      if (!isNaN(d.getTime())) {
        return `${pad2(d.getDate())}/${pad2(d.getMonth() + 1)}/${d.getFullYear()}`;
      }
    }

    return s;
  }

  function trimLeadingZerosNumberMaybe(v) {
    const s = String(v ?? "").trim();
    if (!s) return s;
    if (!/^-?\d+(\.\d+)?$/.test(s)) return s;

    const neg = s.startsWith("-");
    const core = neg ? s.slice(1) : s;

    if (core.includes(".")) {
      const [ip, fp] = core.split(".");
      const ip2 = ip.replace(/^0+(?=\d)/, "");
      return (neg ? "-" : "") + (ip2 === "" ? "0" : ip2) + "." + fp;
    } else {
      const core2 = core.replace(/^0+(?=\d)/, "");
      return (neg ? "-" : "") + (core2 === "" ? "0" : core2);
    }
  }

  function formatRow(row, headers) {
    return row.map((v, i) => {
      const raw = String(v ?? "").trim();
      const h = String(headers?.[i] ?? "").toLowerCase();
      if (h.includes("date")) return formatDateMaybe(raw);
      if (h.includes("weight") || h.includes("kg") || h === "wgt") return trimLeadingZerosNumberMaybe(raw);
      return raw;
    });
  }

  function getHeadersForPreview() {
    return taskHeaders.length
      ? taskHeaders
      : (taskRows.length ? Array.from({length: Math.max(...taskRows.map(r => r.length))}, (_,i)=>`Field${i+1}`) : []);
  }

  // ---- Modal editor ----
  function openEditor(realIndex) {
    const row = taskRows[realIndex];
    if (!row) return;

    lastFocusEl = document.activeElement;
    editingRealIndex = realIndex;
    editingHeaders = getHeadersForPreview();
    editingInputs = [];

    modalTitle.textContent = "Edit Row";
    modalSubtitle.textContent = selectedTask
      ? `Task ${selectedTask.idx}: ${selectedTask.name} — Row ${realIndex + 1}`
      : `Row ${realIndex + 1}`;

    modalGrid.innerHTML = "";

    for (let i = 0; i < editingHeaders.length; i++) {
      const h = editingHeaders[i];
      const label = document.createElement("label");
      label.title = h;
      label.textContent = h;

      const inp = document.createElement("input");
      inp.type = "text";
      inp.value = row[i] ?? "";
      inp.dataset.colIndex = String(i);

      inp.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter") { ev.preventDefault(); saveEditor(); }
        if (ev.key === "Escape") { ev.preventDefault(); closeEditor(false); }
      });

      modalGrid.appendChild(label);
      modalGrid.appendChild(inp);
      editingInputs.push(inp);
    }

    overlay.classList.add("show");
    overlay.setAttribute("aria-hidden", "false");
    setTimeout(() => editingInputs[0]?.focus?.(), 0);
  }

  function closeEditor(keepFocus = true) {
    overlay.classList.remove("show");
    overlay.setAttribute("aria-hidden", "true");

    editingRealIndex = null;
    editingHeaders = [];
    editingInputs = [];
    modalGrid.innerHTML = "";

    if (keepFocus && lastFocusEl && typeof lastFocusEl.focus === "function") {
      setTimeout(() => lastFocusEl.focus(), 0);
    }
    lastFocusEl = null;
  }

  function saveEditor() {
    if (editingRealIndex === null) return;
    const idx = editingRealIndex;

    const updated = editingHeaders.map((h, i) => editingInputs[i]?.value ?? "");
    taskRows[idx] = formatRow(updated, editingHeaders);

    closeEditor(true);
    renderPreview();
  }

  function deleteEditorRow() {
    if (editingRealIndex === null) return;
    const idx = editingRealIndex;
    if (!confirm(`Delete row #${idx + 1}?`)) return;

    taskRows.splice(idx, 1);
    closeEditor(true);
    renderPreview();
  }

  overlay.addEventListener("click", (ev) => {
    if (ev.target === overlay) closeEditor(true);
  });

  modalCloseBtn.addEventListener("click", () => closeEditor(true));
  modalCancelBtn.addEventListener("click", () => closeEditor(true));
  modalSaveBtn.addEventListener("click", saveEditor);
  modalDeleteBtn.addEventListener("click", deleteEditorRow);

  document.addEventListener("keydown", (ev) => {
    if (ev.key === "Escape" && overlay.classList.contains("show")) {
      ev.preventDefault();
      closeEditor(true);
    }
  });

  // ---- Commands / BLE plumbing ----
  function beginCommand(name, okToken) {
    if (currentCommand) throw new Error(`Busy running ${currentCommand.name}`);

    let resolve, reject;
    const p = new Promise((res, rej) => { resolve = res; reject = rej; });

    currentCommand = { name, okToken, frames: [], resolve, reject };
    setBusy(name);

    connectBtn.disabled = true;
    disconnectBtn.disabled = false;
    taskSelect.disabled = true;
    downloadCsvBtn.disabled = true;

    if (cmdTimer) clearTimeout(cmdTimer);
    cmdTimer = setTimeout(() => {
      const done = currentCommand;
      currentCommand = null;
      setBusy("idle");
      if (done) done.reject(new Error("Timeout"));
      taskSelect.disabled = !(battChar && tasks.length);
      downloadCsvBtn.disabled = !(battChar && taskRows.length);
    }, 12000);

    return p;
  }

  function finishCommand(ok, err) {
    if (!currentCommand) return;
    if (cmdTimer) clearTimeout(cmdTimer);
    cmdTimer = null;

    const done = currentCommand;
    currentCommand = null;

    setBusy("idle");
    connectBtn.disabled = true;
    disconnectBtn.disabled = false;
    taskSelect.disabled = !(battChar && tasks.length);
    downloadCsvBtn.disabled = !(battChar && taskRows.length);

    if (ok) done.resolve(done);
    else done.reject(err || new Error("Command failed"));
  }

  function onFrame(f) {
    if (!currentCommand) return;
    currentCommand.frames.push(f);
    if (isOkFrame(f, currentCommand.okToken)) finishCommand(true);
  }

  function consumeFrames() {
    while (true) {
      const open = rxText.indexOf("[");
      if (open === -1) {
        if (rxText.length > 1024) rxText = rxText.slice(-256);
        return;
      }
      const close = rxText.indexOf("]", open);
      if (close === -1) return;

      const raw = rxText.slice(open, close + 1);
      rxText = rxText.slice(close + 1);

      const cleaned = raw.replace(/\r/g,"").replace(/\n/g,"");
      onFrame(cleaned);
    }
  }

  async function enqueueWrite(str) {
    if (!battChar) throw new Error("Not connected");
    writeQueue.push(str);
    pumpWrites();
  }

  async function pumpWrites() {
    if (writing) return;
    writing = true;
    try {
      while (writeQueue.length) {
        const s = writeQueue.shift();
        await battChar.writeValue(enc.encode(s));
        await sleep(35);
      }
    } catch (e) {
      if (currentCommand) finishCommand(false, e);
    } finally {
      writing = false;
    }
  }

  async function send(cmd, structured = null) {
    if (!battChar) throw new Error("Not connected");

    let out = String(cmd).trim();
    if (!out) return null;

    if (!out.startsWith("[")) out = "[" + out;
    if (!out.endsWith("]")) out += "]";

    if (APPEND_CR) out += "\r";
    if (APPEND_LF) out += "\n";

    let p = null;
    if (structured) p = beginCommand(structured.name, structured.okToken);

    await enqueueWrite(out);
    if (p) return await p;
    return null;
  }

  function esc(s) {
    return String(s ?? "").replace(/[&<>"']/g, (m) => ({
      "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;"
    }[m]));
  }

  function renderTasks() {
    tasksBody.innerHTML = "";
    for (const t of tasks) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${esc(t.idx)}</td>
        <td>${esc(t.name)}</td>
        <td>${esc(t.prefix)}</td>
        <td>${esc(t.suffix)}</td>
        <td>${esc(t.count)}</td>
      `;
      tasksBody.appendChild(tr);
    }

    taskSelect.innerHTML = "";
    if (!tasks.length) {
      taskSelect.appendChild(new Option("(no tasks found)", ""));
      taskSelect.disabled = true;
      return;
    }
    taskSelect.appendChild(new Option("(select a task…)", "", true, false));
    for (const t of tasks) {
      taskSelect.appendChild(new Option(`${t.idx}: ${t.name} (${t.count})`, String(t.idx)));
    }
    taskSelect.disabled = false;
  }

  function renderPreview() {
    previewHead.innerHTML = "";
    previewBody.innerHTML = "";

    const headers = getHeadersForPreview();

    for (const h of headers) {
      const th = document.createElement("th");
      th.textContent = h;
      previewHead.appendChild(th);
    }

    const thActions = document.createElement("th");
    thActions.textContent = "Actions";
    previewHead.appendChild(thActions);

    const rowsToShow = taskRows.slice(0, 200);

    for (let visIndex = 0; visIndex < rowsToShow.length; visIndex++) {
      const realIndex = visIndex;
      const r = rowsToShow[visIndex];

      const tr = document.createElement("tr");
      for (let i = 0; i < headers.length; i++) {
        const td = document.createElement("td");
        td.textContent = r[i] ?? "";
        if (headers[i]?.toLowerCase?.().includes("eid")) td.classList.add("mono");
        tr.appendChild(td);
      }

      const tdAct = document.createElement("td");
      // Stack buttons nicely (better on mobile)
      tdAct.style.display = "flex";
      tdAct.style.flexDirection = "column";
      tdAct.style.gap = "6px";
      tdAct.style.minWidth = "120px";

      const editBtn = document.createElement("button");
      editBtn.className = "btn btnSmall";
      editBtn.textContent = "Edit";
      editBtn.addEventListener("click", () => openEditor(realIndex));

      const delBtn = document.createElement("button");
      delBtn.className = "btn btnSmall btnDanger";
      delBtn.textContent = "Delete";
      delBtn.addEventListener("click", () => {
        if (!confirm(`Delete row #${realIndex + 1}?`)) return;
        taskRows.splice(realIndex, 1);
        renderPreview();
      });

      tdAct.appendChild(editBtn);
      tdAct.appendChild(delBtn);
      tr.appendChild(tdAct);

      previewBody.appendChild(tr);
    }

    if (!selectedTask) {
      previewMeta.textContent = "No task selected.";
    } else {
      previewMeta.textContent =
        `Task ${selectedTask.idx}: ${selectedTask.name} — ${taskRows.length} record(s), ${headers.length} column(s).`;
    }

    downloadCsvBtn.disabled = !(battChar && taskRows.length);
  }

  function toCsv(headers, rows) {
    const escCsv = (v) => {
      const s = String(v ?? "");
      if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
      return s;
    };
    const lines = [];
    if (headers && headers.length) lines.push(headers.map(escCsv).join(","));
    for (const r of rows) lines.push(r.map(escCsv).join(","));
    return lines.join("\n");
  }

  function downloadText(filename, text) {
    const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  async function runXGTASK() {
    const done = await send("[XGTASK]", { name: "Sync tasks", okToken: "XGTASKOK" });

    const rows = done.frames
      .filter(isBracketFrame)
      .filter(fr => fr !== "[XGTASK]" && fr !== "[XGTASKOK]")
      .filter(fr => fr.includes("|"));

    tasks = rows.map(parsePipeFrame)
      .filter(a => a.length >= 2 && a[0] !== "")
      .map(a => ({
        idx: a[0] ?? "",
        name: a[1] ?? "",
        prefix: a[2] ?? "",
        suffix: a[3] ?? "",
        count: a[4] ?? "",
      }));

    renderTasks();
    const now = new Date();
    syncedAtEl.textContent = `Synced: ${now.toLocaleString()}`;
  }

  async function runXSH(idx) {
    const done = await send(`[XSH|${idx}]`, { name: "Get headers", okToken: "XSHOK" });

    const headerFrame = done.frames.find(fr =>
      isBracketFrame(fr) &&
      !isCmdFrame(fr, "XSH") &&
      fr !== "[XSHOK]" &&
      fr.includes("|")
    );

    taskHeaders = headerFrame ? parsePipeFrame(headerFrame) : [];
  }

  async function runCSW(idx) {
    const done = await send(`[CSW|${idx}]`, { name: "Get data", okToken: "CSWOK" });

    const dataFrames = done.frames
      .filter(isBracketFrame)
      .filter(fr => !isCmdFrame(fr, "CSW"))
      .filter(fr => fr !== "[CSWOK]");

    const datasetFrames = dataFrames.filter(fr => fr.includes("|"));
    const rawRows = datasetFrames.map(parsePipeFrame);

    const headers = taskHeaders.length
      ? taskHeaders
      : Array.from({ length: Math.max(0, ...rawRows.map(r => r.length)) }, (_, i) => `Field${i + 1}`);

    taskRows = rawRows.map(r => formatRow(r, headers));
  }

  async function loadSelectedTask(idx) {
    selectedTask = tasks.find(t => String(t.idx) === String(idx)) || { idx, name: "(unknown)" };
    taskHeaders = [];
    taskRows = [];
    renderPreview();

    await runXSH(idx);
    await runCSW(idx);
    renderPreview();
  }

  async function connect() {
    if (!("bluetooth" in navigator)) {
      alert("Web Bluetooth not supported in this browser.");
      return;
    }
    try {
      setStatus("Connecting…", false);
      setBusy("connecting");

      device = await navigator.bluetooth.requestDevice({
        filters: [{ services: [UUID_BATT_SVC] }],
        optionalServices: [UUID_BATT_SVC, "generic_access", "device_information"],
      });

      deviceNameEl.textContent = device.name ? `Selected: ${device.name}` : "";
      device.addEventListener("gattserverdisconnected", () => cleanup());

      const server = await device.gatt.connect();
      const svc = await server.getPrimaryService(UUID_BATT_SVC);
      battChar = await svc.getCharacteristic(UUID_BATT_CHR);

      await battChar.startNotifications();
      battChar.addEventListener("characteristicvaluechanged", (ev) => {
        const u8 = u8FromDV(ev.target.value);
        const chunk = dec.decode(u8);
        rxText += chunk;
        if (rxText.length > MAX_TEXT) rxText = rxText.slice(-MAX_TEXT);
        consumeFrames();
      });

      setStatus("Connected", true);
      setBusy("idle");

      connectBtn.disabled = true;
      disconnectBtn.disabled = false;

      tasks = [];
      selectedTask = null;
      taskHeaders = [];
      taskRows = [];
      renderTasks();
      renderPreview();

      await runXGTASK();

    } catch (e) {
      cleanup();
      alert(`Connect failed: ${e?.message || e}`);
    }
  }

  function cleanup() {
    closeEditor(false);

    try { battChar?.stopNotifications?.().catch(()=>{}); } catch {}
    battChar = null;

    try { if (device?.gatt?.connected) device.gatt.disconnect(); } catch {}
    device = null;

    connectBtn.disabled = false;
    disconnectBtn.disabled = true;
    taskSelect.disabled = true;
    downloadCsvBtn.disabled = true;

    deviceNameEl.textContent = "";
    syncedAtEl.textContent = "";

    tasks = [];
    selectedTask = null;
    taskHeaders = [];
    taskRows = [];
    renderTasks();
    renderPreview();

    setStatus("Disconnected", false);
    setBusy("idle");
  }

  connectBtn.addEventListener("click", connect);
  disconnectBtn.addEventListener("click", cleanup);

  taskSelect.addEventListener("change", async () => {
    try {
      const idx = taskSelect.value;
      if (!idx) return;
      await loadSelectedTask(idx);
    } catch (e) {
      alert(`Failed to load task: ${e?.message || e}`);
    }
  });

  downloadCsvBtn.addEventListener("click", () => {
    if (!selectedTask) return;

    const safeName = String(selectedTask.name || `task_${selectedTask.idx}`)
      .replace(/[^\w\-]+/g,"_")
      .slice(0, 60);

    const headers = getHeadersForPreview();
    const csv = toCsv(headers, taskRows);
    downloadText(`${safeName}.csv`, csv);
  });

  setStatus("Disconnected", false);
  setBusy("idle");
})();
</script>
</body>
</html>
