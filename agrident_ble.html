<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Agrident Task Sync → CSV</title>
  <style>
    :root { --bd:#ddd; --muted:#666; --bg:#f6f6f6; }
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; max-width: 1200px; }
    h1 { margin: 0 0 6px; }
    .muted { color: var(--muted); font-size: 13px; }
    .card { border: 1px solid var(--bd); border-radius: 12px; padding: 12px; margin: 12px 0; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button, input, select { padding: 8px 10px; font-size: 14px; }
    input { width: 520px; max-width: 100%; }
    .pill { padding: 2px 10px; border-radius: 999px; background: #eee; font-size: 12px; }
    .ok { background: #e7f7ea; }
    .bad { background: #ffecec; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    pre { background: var(--bg); padding: 12px; border-radius: 8px; height: 240px; overflow:auto; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #eee; padding: 6px 8px; text-align: left; font-size: 13px; }
    th { background: #fafafa; position: sticky; top: 0; }
    .grid { display: grid; gap: 12px; grid-template-columns: 1fr; }
    @media (min-width: 980px) { .grid { grid-template-columns: 1fr 1fr; } }
    .right { margin-left:auto; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .hint { background:#fffbe6; border:1px solid #ffe58f; padding:8px 10px; border-radius:10px; font-size:13px; }
  </style>
</head>
<body>
  <h1>Agrident Task Sync → CSV</h1>
  <div class="muted">
    Workflow: Connect → Sync (auto gets Tasks) → Select Task (auto gets Headers + Data) → Download CSV.
  </div>

  <div class="card">
    <div class="row">
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
      <span id="status" class="pill bad">Disconnected</span>
      <span id="devName" class="muted"></span>
      <span id="busy" class="pill">idle</span>
      <span class="right muted" id="syncedAt"></span>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="syncBtn" disabled>Sync</button>

      <select id="taskSelect" disabled>
        <option value="">(sync to load tasks)</option>
      </select>

      <button id="downloadCsvBtn" disabled>Download CSV</button>

      <label class="muted"><input id="appendCR" type="checkbox"> Append <code>\r</code></label>
      <label class="muted"><input id="appendLF" type="checkbox"> Append <code>\n</code></label>
      <label class="muted"><input id="autoScroll" type="checkbox" checked> Auto-scroll</label>
      <label class="muted"><input id="hexAlways" type="checkbox"> Log HEX</label>
    </div>

    <div class="row" style="margin-top:10px;">
      <input id="customCmd" placeholder="Advanced: custom command e.g. [XSTIMEFORMAT|21] or [CEW|0]" />
      <button id="sendBtn" disabled>Send</button>
      <button id="clearBtn">Clear logs</button>
    </div>

    <div class="hint" style="margin-top:10px;">
      Tip: Leave “Append \\r/\\n” <b>off</b> unless you’ve proven the wand needs it (your logs suggest it doesn’t).
    </div>
  </div>

  <div class="card">
    <h3>Tasks</h3>
    <div class="muted">From <code>[XGTASK] ... [XGTASKOK]</code></div>
    <div style="max-height: 220px; overflow:auto; border:1px solid #eee; border-radius:8px; margin-top:8px;">
      <table id="tasksTable">
        <thead>
          <tr>
            <th>Index</th>
            <th>Name</th>
            <th>Prefix</th>
            <th>Suffix</th>
            <th>Count</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <h3>Selected task preview</h3>
    <div class="muted" id="previewMeta">No task selected.</div>
    <div style="max-height: 280px; overflow:auto; border:1px solid #eee; border-radius:8px; margin-top:8px;">
      <table id="previewTable">
        <thead><tr id="previewHeadRow"></tr></thead>
        <tbody id="previewBody"></tbody>
      </table>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>Raw log</h3>
      <pre id="log" class="mono"></pre>
    </div>
    <div class="card">
      <h3>Frames (parsed)</h3>
      <pre id="frames" class="mono"></pre>
    </div>
  </div>

<script>
(() => {
  // ===== UUIDs =====
  const UUID_BATT_SVC = "battery_service";
  const UUID_BATT_CHR = "battery_level";

  // ===== UI =====
  const connectBtn = document.getElementById("connectBtn");
  const disconnectBtn = document.getElementById("disconnectBtn");
  const statusEl = document.getElementById("status");
  const devNameEl = document.getElementById("devName");
  const busyEl = document.getElementById("busy");
  const syncedAtEl = document.getElementById("syncedAt");

  const syncBtn = document.getElementById("syncBtn");
  const taskSelect = document.getElementById("taskSelect");
  const downloadCsvBtn = document.getElementById("downloadCsvBtn");

  const appendCR = document.getElementById("appendCR");
  const appendLF = document.getElementById("appendLF");
  const autoScroll = document.getElementById("autoScroll");
  const hexAlways = document.getElementById("hexAlways");

  const customCmd = document.getElementById("customCmd");
  const sendBtn = document.getElementById("sendBtn");
  const clearBtn = document.getElementById("clearBtn");

  const logEl = document.getElementById("log");
  const framesEl = document.getElementById("frames");

  const tasksTbody = document.querySelector("#tasksTable tbody");

  const previewMeta = document.getElementById("previewMeta");
  const previewHeadRow = document.getElementById("previewHeadRow");
  const previewBody = document.getElementById("previewBody");

  function setStatus(text, ok) {
    statusEl.textContent = text;
    statusEl.classList.toggle("ok", !!ok);
    statusEl.classList.toggle("bad", !ok);
  }
  function setBusy(text, ok = null) {
    busyEl.textContent = text;
    if (ok === null) busyEl.classList.remove("ok","bad");
    else {
      busyEl.classList.toggle("ok", !!ok);
      busyEl.classList.toggle("bad", !ok);
    }
  }
  function log(line) {
    logEl.textContent += line + "\n";
    if (autoScroll.checked) logEl.scrollTop = logEl.scrollHeight;
  }
  function frame(line) {
    framesEl.textContent += line + "\n";
    if (autoScroll.checked) framesEl.scrollTop = framesEl.scrollHeight;
  }
  function clearAll() {
    logEl.textContent = "";
    framesEl.textContent = "";
    log("[ALL] Cleared");
  }

  // ===== Text/bytes =====
  const enc = new TextEncoder();
  const dec = new TextDecoder();
  function u8FromDV(dv) { return new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength); }
  function toHex(u8) { return Array.from(u8).map(b => b.toString(16).padStart(2,"0")).join(" "); }

  // ===== BLE state =====
  let device = null;
  let battChar = null;

  // ===== Robust frame buffer =====
  let rxText = "";
  const MAX_TEXT = 60000;

  function consumeFrames() {
    while (true) {
      const open = rxText.indexOf("[");
      if (open === -1) {
        if (rxText.length > 1024) rxText = rxText.slice(-256);
        return;
      }
      const close = rxText.indexOf("]", open);
      if (close === -1) return;

      const raw = rxText.slice(open, close + 1);
      rxText = rxText.slice(close + 1);

      const cleaned = raw.replace(/\r/g,"").replace(/\n/g,"");
      frame(cleaned);
      onFrame(cleaned);
    }
  }

  // ===== Write queue =====
  const writeQueue = [];
  let writing = false;
  async function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  async function enqueueWrite(str) {
    if (!battChar) throw new Error("Not connected");
    writeQueue.push(str);
    pumpWrites();
  }

  async function pumpWrites() {
    if (writing) return;
    writing = true;
    try {
      while (writeQueue.length) {
        const s = writeQueue.shift();
        await battChar.writeValue(enc.encode(s));
        await sleep(35);
      }
    } catch (e) {
      log(`[ERR] write: ${e?.message || e}`);
      setBusy("idle", false);
      failCurrentCommand(e);
    } finally {
      writing = false;
    }
  }

  // ===== Structured commands =====
  let currentCommand = null; // { name, okToken, frames, resolve, reject }
  let cmdTimer = null;

  function uiBusy(isBusy) {
    // Main UX
    syncBtn.disabled = isBusy || !battChar;
    taskSelect.disabled = isBusy || !battChar || tasks.length === 0;
    downloadCsvBtn.disabled = isBusy || !battChar || taskRows.length === 0;

    // Advanced
    sendBtn.disabled = isBusy || !battChar;
  }

  function beginCommand(name, okToken) {
    if (currentCommand) throw new Error(`Busy running ${currentCommand.name}`);

    let resolve, reject;
    const p = new Promise((res, rej) => { resolve = res; reject = rej; });

    currentCommand = { name, okToken, frames: [], resolve, reject };
    setBusy(name);
    uiBusy(true);

    if (cmdTimer) clearTimeout(cmdTimer);
    cmdTimer = setTimeout(() => {
      log(`[WARN] Timeout waiting for ${name} (${okToken})`);
      const done = currentCommand;
      currentCommand = null;
      setBusy("idle", false);
      uiBusy(false);
      done?.reject(new Error("Timeout"));
    }, 12000);

    return p;
  }

  function finishCurrentCommand(ok, err = null) {
    if (!currentCommand) return;
    if (cmdTimer) clearTimeout(cmdTimer);
    cmdTimer = null;

    const done = currentCommand;
    currentCommand = null;

    setBusy("idle", ok);
    uiBusy(false);

    if (ok) done.resolve(done);
    else done.reject(err || new Error("Command failed"));
  }

  function failCurrentCommand(err) {
    if (!currentCommand) return;
    finishCurrentCommand(false, err);
  }

  // ===== App data =====
  let tasks = [];
  let taskHeaders = [];
  let taskRows = [];
  let selectedTask = null; // { idx, name, ... }

  // ===== Parsing helpers =====
  function parsePipeFrame(frameStr) {
    const inner = frameStr.slice(1, -1);
    return inner.split("|");
  }
  function isBracketFrame(s) { return s.startsWith("[") && s.endsWith("]"); }
  function isCmdFrame(s, cmd) { return s.startsWith("[" + cmd); } // [XSH] and [XSH|0]
  function isOkFrame(s, okToken) { return s.includes(okToken); }

  // ===== Frame handler =====
  function onFrame(f) {
    if (!currentCommand) return;
    currentCommand.frames.push(f);
    if (isOkFrame(f, currentCommand.okToken)) finishCurrentCommand(true);
  }

  // ===== Rendering =====
  function esc(s) {
    return String(s ?? "").replace(/[&<>"']/g, (m) => ({
      "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;"
    }[m]));
  }

  function renderTasks() {
    tasksTbody.innerHTML = "";
    for (const t of tasks) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${esc(t.idx)}</td>
        <td>${esc(t.name)}</td>
        <td>${esc(t.prefix)}</td>
        <td>${esc(t.suffix)}</td>
        <td>${esc(t.count)}</td>
      `;
      tasksTbody.appendChild(tr);
    }

    taskSelect.innerHTML = "";
    if (!tasks.length) {
      taskSelect.innerHTML = `<option value="">(sync to load tasks)</option>`;
      taskSelect.disabled = true;
      return;
    }

    taskSelect.appendChild(new Option("(select a task…)", "", true, false));
    for (const t of tasks) {
      taskSelect.appendChild(new Option(`${t.idx}: ${t.name} (${t.count})`, String(t.idx)));
    }
    taskSelect.disabled = false;
  }

  function renderPreview() {
    // headers row
    previewHeadRow.innerHTML = "";
    previewBody.innerHTML = "";

    const headers = taskHeaders.length
      ? taskHeaders
      : (taskRows.length ? Array.from({length: Math.max(...taskRows.map(r => r.length))}, (_,i)=>`Field${i+1}`) : []);

    for (const h of headers) {
      const th = document.createElement("th");
      th.textContent = h;
      previewHeadRow.appendChild(th);
    }

    const rowsToShow = taskRows.slice(0, 200); // keep UI snappy
    for (const r of rowsToShow) {
      const tr = document.createElement("tr");
      for (let i = 0; i < headers.length; i++) {
        const td = document.createElement("td");
        td.textContent = r[i] ?? "";
        tr.appendChild(td);
      }
      previewBody.appendChild(tr);
    }

    if (!selectedTask) {
      previewMeta.textContent = "No task selected.";
    } else {
      previewMeta.textContent =
        `Task ${selectedTask.idx}: ${selectedTask.name} — ` +
        `${taskRows.length} record(s), ${headers.length} column(s).`;
    }

    downloadCsvBtn.disabled = (!battChar || taskRows.length === 0);
  }

  // ===== CSV =====
  function toCsv(headers, rows) {
    const escCsv = (v) => {
      const s = String(v ?? "");
      if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
      return s;
    };
    const lines = [];
    if (headers && headers.length) lines.push(headers.map(escCsv).join(","));
    for (const r of rows) lines.push(r.map(escCsv).join(","));
    return lines.join("\n");
  }

  function downloadText(filename, text) {
    const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  // ===== Send (raw + structured) =====
  async function send(cmd, structured = null) {
    if (!battChar) throw new Error("Not connected");

    let out = String(cmd).trim();
    if (!out) return null;

    if (!out.startsWith("[")) out = "[" + out;
    if (!out.endsWith("]")) out += "]";

    if (appendCR.checked) out += "\r";
    if (appendLF.checked) out += "\n";

    log(`[TX] ${out.replace(/\r/g,"\\r").replace(/\n/g,"\\n")}`);

    let p = null;
    if (structured) p = beginCommand(structured.name, structured.okToken);

    await enqueueWrite(out);

    if (p) return await p;
    return null;
  }

  // ===== Command result processors =====
  async function runXGTASK() {
    const done = await send("[XGTASK]", { name: "XGTASK", okToken: "XGTASKOK" });

    const rows = done.frames
      .filter(isBracketFrame)
      .filter(fr => fr !== "[XGTASK]" && fr !== "[XGTASKOK]")
      .filter(fr => fr.includes("|"));

    tasks = rows.map(parsePipeFrame)
      .filter(a => a.length >= 2 && a[0] !== "")
      .map(a => ({
        idx: a[0] ?? "",
        name: a[1] ?? "",
        prefix: a[2] ?? "",
        suffix: a[3] ?? "",
        count: a[4] ?? "",
      }));

    log(`[OK] Parsed ${tasks.length} task(s)`);
    renderTasks();
  }

  async function runXSH(idx) {
    const done = await send(`[XSH|${idx}]`, { name: "XSH", okToken: "XSHOK" });

    // ✅ ignore echo frames like [XSH|0], and [XSHOK]
    const headerFrame = done.frames.find(fr =>
      isBracketFrame(fr) &&
      !isCmdFrame(fr, "XSH") &&
      fr !== "[XSHOK]" &&
      fr.includes("|")
    );

    taskHeaders = headerFrame ? parsePipeFrame(headerFrame) : [];
    log(`[OK] Headers (${idx}): ${taskHeaders.join(", ") || "(none)"}`);
  }

  async function runCSW(idx) {
    const done = await send(`[CSW|${idx}]`, { name: "CSW", okToken: "CSWOK" });

    const dataFrames = done.frames
      .filter(isBracketFrame)
      .filter(fr => !isCmdFrame(fr, "CSW")) // removes [CSW] and [CSW|idx]
      .filter(fr => fr !== "[CSWOK]");

    // Prefix lines like [Manual Weight] have no pipes → ignore them for dataset rows
    const datasetFrames = dataFrames.filter(fr => fr.includes("|"));
    taskRows = datasetFrames.map(parsePipeFrame);

    log(`[OK] Parsed ${taskRows.length} dataset row(s) for task ${idx}`);
  }

  async function loadSelectedTask(idx) {
    if (!idx) return;
    selectedTask = tasks.find(t => String(t.idx) === String(idx)) || { idx, name: "(unknown)" };

    // reset preview state
    taskHeaders = [];
    taskRows = [];
    renderPreview();

    // sequential: headers then data
    await runXSH(idx);
    await runCSW(idx);
    renderPreview();
  }

  // ===== Connect / Disconnect =====
  async function connect() {
    if (!("bluetooth" in navigator)) {
      alert("Web Bluetooth not supported in this browser.");
      return;
    }

    try {
      setStatus("Connecting…", false);
      log("[BLE] requestDevice...");

      device = await navigator.bluetooth.requestDevice({
        filters: [{ services: [UUID_BATT_SVC] }],
        optionalServices: [UUID_BATT_SVC, "generic_access", "device_information"],
      });

      log(`[BLE] Selected: "${device.name || "(unnamed)"}"`);
      devNameEl.textContent = device.name ? `Selected: "${device.name}"` : "";

      device.addEventListener("gattserverdisconnected", () => {
        log("[BLE] Disconnected.");
        cleanup();
      });

      const server = await device.gatt.connect();
      const svc = await server.getPrimaryService(UUID_BATT_SVC);
      battChar = await svc.getCharacteristic(UUID_BATT_CHR);

      log(`[BLE] BATT(2A19) props: notify=${battChar.properties.notify} indicate=${battChar.properties.indicate} read=${battChar.properties.read} write=${battChar.properties.write} wnr=${battChar.properties.writeWithoutResponse}`);

      await battChar.startNotifications();
      battChar.addEventListener("characteristicvaluechanged", (ev) => {
        const u8 = u8FromDV(ev.target.value);
        if (hexAlways.checked) log(`[RX HEX] ${toHex(u8)}`);
        const chunk = dec.decode(u8);
        log(`[RX TXT] (${u8.length}) ${chunk.replace(/\r/g,"\\r").replace(/\n/g,"\\n")}`);

        rxText += chunk;
        if (rxText.length > MAX_TEXT) rxText = rxText.slice(-MAX_TEXT);
        consumeFrames();
      });

      setStatus("Connected", true);
      setBusy("idle");
      connectBtn.disabled = true;
      disconnectBtn.disabled = false;
      syncBtn.disabled = false;
      sendBtn.disabled = false;

      // reset app state
      tasks = [];
      taskHeaders = [];
      taskRows = [];
      selectedTask = null;
      syncedAtEl.textContent = "";
      renderTasks();
      renderPreview();

      log("[READY] Click Sync to retrieve tasks.");

    } catch (e) {
      log(`[ERR] ${e?.message || e}`);
      cleanup();
    }
  }

  function cleanup() {
    try { battChar?.stopNotifications?.().catch(()=>{}); } catch {}
    battChar = null;

    try { if (device?.gatt?.connected) device.gatt.disconnect(); } catch {}
    device = null;

    connectBtn.disabled = false;
    disconnectBtn.disabled = true;
    syncBtn.disabled = true;
    taskSelect.disabled = true;
    downloadCsvBtn.disabled = true;
    sendBtn.disabled = true;

    tasks = [];
    taskHeaders = [];
    taskRows = [];
    selectedTask = null;
    syncedAtEl.textContent = "";

    renderTasks();
    renderPreview();

    setStatus("Disconnected", false);
    setBusy("idle");
  }

  // ===== Events =====
  connectBtn.addEventListener("click", connect);
  disconnectBtn.addEventListener("click", cleanup);

  clearBtn.addEventListener("click", clearAll);

  sendBtn.addEventListener("click", async () => {
    try { await send(customCmd.value); }
    catch (e) { log(`[ERR] ${e?.message || e}`); }
  });

  // ✅ Sync retrieves tasks (and does NOT auto-fetch headers/data until user picks one)
  syncBtn.addEventListener("click", async () => {
    try {
      selectedTask = null;
      taskHeaders = [];
      taskRows = [];
      renderPreview();

      await runXGTASK();
      const now = new Date();
      syncedAtEl.textContent = `Synced: ${now.toLocaleString()}`;

      // keep dropdown at placeholder
      taskSelect.value = "";
    } catch (e) {
      log(`[ERR] ${e?.message || e}`);
    }
  });

  // ✅ Selecting a task fetches headers then data automatically
  taskSelect.addEventListener("change", async () => {
    try {
      const idx = taskSelect.value;
      if (!idx) return;

      await loadSelectedTask(idx);
    } catch (e) {
      log(`[ERR] ${e?.message || e}`);
    }
  });

  downloadCsvBtn.addEventListener("click", () => {
    if (!selectedTask) return;

    const safeName = String(selectedTask.name || `task_${selectedTask.idx}`)
      .replace(/[^\w\-]+/g,"_")
      .slice(0, 60);

    const headers = taskHeaders.length
      ? taskHeaders
      : (taskRows.length ? Array.from({length: Math.max(...taskRows.map(r => r.length))}, (_,i)=>`Field${i+1}`) : []);

    const csv = toCsv(headers, taskRows);
    downloadText(`${safeName}.csv`, csv);

    log(`[OK] Downloaded CSV: ${safeName}.csv (${taskRows.length} rows, ${headers.length} cols)`);
  });

  // init
  log("[READY] Serve via http://localhost (python -m http.server 8000)");
})();
</script>
</body>
</html>
